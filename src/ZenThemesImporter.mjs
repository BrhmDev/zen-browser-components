const kZenStylesheetThemeHeader = `
/* Zen Themes - Generated by ZenThemeImporter.
  * DO NOT EDIT THIS FILE DIRECTLY!
  * Your changes will be overwritten.
  * Instead, go to the preferences and edit the themes there.
  */
`;
const kenStylesheetFooter = `
/* End of Zen Themes */
`;

var gZenStylesheetManager = {
  async writeStylesheet(path, themes) {
    let content = kZenStylesheetThemeHeader;
    for (let theme of themes) {
      if (theme.enabled !== undefined && !theme.enabled) {
        continue;
      }
      content += this.getThemeCSS(theme);
    }
    content += kenStylesheetFooter;
    let buffer = new TextEncoder().encode(content);
    await IOUtils.write(path, buffer);
  },

  getThemeCSS(theme) {
    let css = '\n';
    if (theme._readmeURL) {
      css += `/* Name: ${theme.name} */\n`;
      css += `/* Description: ${theme.description} */\n`;
      css += `/* Author: @${theme.author} */\n`;
      css += `/* Readme: ${theme.readme} */\n`;
    }
    css += `@import url("${theme._chromeURL}");\n`;
    return css;
  },
};

var gZenThemeImporter = new (class {
  constructor() {
    console.info('ZenThemeImporter: Initiating Zen theme importer');
    try {
      window.SessionStore.promiseInitialized.then(async () => {
        this.insertStylesheet();

        const themesWithPreferences = await Promise.all(
          Object.values(await ZenThemesCommon.getThemes()).map(async (theme) => {
            const preferences = await ZenThemesCommon.getThemePreferences(theme);

            return {
              name: theme.name,
              enabled: theme.enabled,
              preferences,
            };
          })
        );

        this.writeToDom(themesWithPreferences);
      });
      console.info('ZenThemeImporter: Zen theme imported');
    } catch (e) {
      console.error('ZenThemeImporter: Error importing Zen theme: ', e);
    }
    Services.prefs.addObserver('zen.themes.updated-value-observer', this.rebuildThemeStylesheet.bind(this), false);
  }

  get sss() {
    if (!this._sss) {
      this._sss = Cc['@mozilla.org/content/style-sheet-service;1'].getService(Ci.nsIStyleSheetService);
    }
    return this._sss;
  }

  get styleSheetPath() {
    return PathUtils.join(PathUtils.profileDir, 'chrome', 'zen-themes.css');
  }

  async rebuildThemeStylesheet() {
    this._themes = null;
    await this.updateStylesheet();
  }

  get styleSheetURI() {
    if (!this._styleSheetURI) {
      this._styleSheetURI = Services.io.newFileURI(new FileUtils.File(this.styleSheetPath));
    }
    return this._styleSheetURI;
  }

  getStylesheetURIForTheme(theme) {
    return Services.io.newFileURI(new FileUtils.File(PathUtils.join(ZenThemesCommon.getThemeFolder(theme.id), 'chrome.css')));
  }

  async insertStylesheet() {
    if (await IOUtils.exists(this.styleSheetPath)) {
      await this.sss.loadAndRegisterSheet(this.styleSheetURI, this.sss.AGENT_SHEET);
    }
  }

  async removeStylesheet() {
    await this.sss.unregisterSheet(this.styleSheetURI, this.sss.AGENT_SHEET);
  }

  async updateStylesheet() {
    await this.removeStylesheet();

    const themes = Object.values(await ZenThemesCommon.getThemes());
    await this.writeStylesheet(themes);

    const themesWithPreferences = await Promise.all(
      themes.map(async (theme) => {
        const preferences = await ZenThemesCommon.getThemePreferences(theme);

        return {
          name: theme.name,
          enabled: theme.enabled,
          preferences,
        };
      })
    );

    this.setDefaults(themesWithPreferences);
    this.writeToDom(themesWithPreferences);

    await this.insertStylesheet();
  }

  setDefaults(themesWithPreferences) {
    for (const { preferences, enabled } of themesWithPreferences) {
      if (enabled !== undefined && !enabled) {
        continue;
      }

      for (const { type, property, defaultValue } of preferences) {
        if (defaultValue === undefined) {
          continue;
        }

        switch (type) {
          case 'checkbox': {
            const value = Services.prefs.getBoolPref(property, false);
            if (typeof defaultValue !== 'boolean') {
              console.log(`[ZenThemesImporter]: Warning, invalid data type received for expected type boolean, skipping.`);
              continue;
            }

            if (!value) {
              Services.prefs.setBoolPref(property, defaultValue);
            }
            break;
          }

          default: {
            const value = Services.prefs.getStringPref(property, 'zen-property-no-saved');

            if (typeof defaultValue !== 'string' && typeof defaultValue !== 'number') {
              console.log(`[ZenThemesImporter]: Warning, invalid data type received (${typeof defaultValue}), skipping.`);
              continue;
            }

            if (value === 'zen-property-no-saved') {
              Services.prefs.setStringPref(property, defaultValue.toString());
            }
          }
        }
      }
    }
  }

  writeToDom(themesWithPreferences) {
    const browser = ZenThemesCommon.getBrowser();

    for (const { enabled, preferences, name } of themesWithPreferences) {
      const sanitizedName = `theme-${name?.replaceAll(/\s/g, '-')?.replaceAll(/[^A-z_-]+/g, '')}`;

      if (enabled !== undefined && !enabled) {
        const element = browser.document.getElementById(sanitizedName);

        if (element) {
          element.remove();
        }

        for (const { property } of preferences.filter(({ type }) => type !== 'checkbox')) {
          const sanitizedProperty = property?.replaceAll(/\./g, '-');

          if (document.querySelector(':root').style.hasProperty(`--${sanitizedProperty}`)) {
            document.querySelector(':root').style.removeProperty(`--${sanitizedProperty}`);
          }
        }

        continue;
      }

      for (const { property, type } of preferences) {
        const value = Services.prefs.getStringPref(property, '');
        const sanitizedProperty = property?.replaceAll(/\./g, '-');

        switch (type) {
          case 'dropdown': {
            if (value !== '') {
              let element = browser.document.getElementById(sanitizedName);

              if (!element) {
                element = browser.document.createElement('div');

                element.style.display = 'none';
                element.setAttribute('id', sanitizedName);

                browser.document.body.appendChild(element);
              }

              element.setAttribute(sanitizedProperty, value);
            }
            break;
          }

          case 'string': {
            if (value === '') {
              document.querySelector(':root').style.removeProperty(`--${sanitizedProperty}`);
            } else {
              document.querySelector(':root').style.setProperty(`--${sanitizedProperty}`, value);
            }
            break;
          }

          default: {
          }
        }
      }
    }
  }

  async writeStylesheet(themeList) {
    const themes = [];
    this._themes = null;

    for (let theme of themeList) {
      theme._chromeURL = this.getStylesheetURIForTheme(theme).spec;
      themes.push(theme);
    }

    await gZenStylesheetManager.writeStylesheet(this.styleSheetPath, themes);
  }
})();
